22-Ja-2024

ested class, Ier class, static class TopLevelested,
Outer o;
Outer.Ier oi;
Outer.TopLevelested tl;
o ew Outer();
tl ew Outer.TopLevelested();
oio.ew Ier();

Changed Java version to 17 while creating 

class - creator
class - user of the class These are 2 different people

Access specifier - private, public, protected

How to specifiy a module ?
module-info.java

module java.base
open module java.base
open module java.base requires
open module java.base requires.module m2
open module java.base requires modulem2 exports 

Sealed class - uses permits
Sealed - private

public sealed interface permits SomeSealedInterfac
eg. All Beings
Living Beings

permits Living Beeings, 
permits Non-Living Beeings

final - no furthe sub-class
sealed - fixed and known sub-types

A sub-type of a sealed type can be final, sealed or non-sealed

Cuboid is-a-rectangle -- Inheritance
Cuboid has -a-rectangel-- Composition  (instead of extends keyword, we put the class 
as a variable).  So, now Rectangle is a member of Cuboid.

comparable comparator -both are interfaces
Comparable is a type which has a natural ordering
whichever is comparable can be sorted using Collectios.sort() and Array.sort()
Comparator is a way to sort in a different way

Comparator -- compare() - takes 2 parametes - logic for any ordering
Collections.sort -- takes 1 parameter - logic for natural ordering

Comparable ===compareTo() method - returns intger
Comparator ---compare() method - returns integer

An Iterable uses an Iterator to iterate

Iterator---has a method called iterator()
Iteration can be done if we have an Iterator (availble since 1.2)
Now, Collections was already having a method called iterator()
We would like to do iterations for anything which has iterator

They introduced a super-interface called Iterable and made Collection extend from Iterable

public interface Iterable<E>{
    public abstract Iterator<E> iterator();
    
public interface Iterator<E>{
    public abstract boolean hasNext();
    public abstract E next();
    public abstract void remove();
    
Paths - class - static methods were being used from Java 8
Path - interface

Now, static methods are allowed in interface.  So, we can directly have methods in Path interface without depending on Paths class

Instance methods in Path
getFileName()
getName()
getParent()
endsWith (Path other)
equals (Object other)

Hotel
Guest

Jigar Shah
Vathsal Doshi


Example of return type object being returned by a static method
Enum stores Objects.   This is being returned

native - we don't write code in Java

volative
synchronized

Literals:(3) 
null true false

Reserved Keywords
types:(16)
byte short int long float double char boolean void
class interface enum package import
extends implements

modifiers:(12)
private public protected default static abstract native final volatile synchronized strictfp transient

statements:(12)
for while do if else switch case break continue return throw assert 

operators:(2)
new instanceof

exceptions:(4)
try catch finally throws

Object Reference:(2)
super this

unused:(3)
const goto _

Contextual Keywords:(5)
record permits sealed non-sealed yield module open requires opens exports to

Only if Rectangle method is overridden, then we will get True while comparing using .equals method

scp  computer-name@192.168.0.0 - Transfer between 2 computers on same network

43 standard Functional Interfaces  (important for Streams)
mainly use 3 primitive types - int,long,double

Functional Interfaces
Single-input Consumer types with return void
Consumer<T>
IntConsumer
LongConsumer
DoubleConsumer

Two-input Consumer types with return void
ObjIntConsumer<T>
ObjLongConsumer<T>
ObjDoubleConsumer<T>
BiConsumer<T,U>

no-input Supplier types with valid return type 
IntSupplier
LongSupplier
DoubleSupplier
Supplier<T>
BooleanSupplier

one or more inputs Predicate types with boolean return type
Predicate
BiPredicate
IntPredicate
LongPredicate
DoublePredicate

one or two inputs Function type and valid return type
Function<T,R>    T is input, R is return type
IntToLongFunction
IntToDoubleFunction
LongToIntFunction
LongToDoubleFunction
DoubleToIntFunction
DoubleToLongFunction
IntFunction<R>
LongFunction<R>
DoubleFunction<R>
ToIntFunction<T>
ToLongFunction<T>
ToDoubleFunction<T>
BiFunction<T,U,R>
ToIntBiFunction<T,U>
ToLongBiFunction<T,U>
ToDoubleBiFunction<T,U>

UnaryOperator<T>
IntUnaryOperator
LongUnaryOperator
DoubleUnaryOperator

BinaryOperator<T>
IntBinaryOperator
LongBinaryOperator
DoubleBinaryOperator


Method names
Consumer --> accept -- 
Supplier --> get --  getAsInt(), getAsLong(), getAsDouble, getAsBoolean()
Predicate--->test - 
Function --->apply --- applyAsInt(),applyAsLong(), applyAsDouble()

Generics (eg accountNumber)

Virtual Threads (Java spawns virtual threads, but from the OS point of view, is only one thread

Structured Concurrency - from Java 5 - executor service interface - classes which implement that interface - user need not create a separate thread. The concurrency is managed by the executor service. Scheduled Executor Service

Runnable -no input, no output
Callable -no input, returns a value V (Future interfac) - like a token for enquiring about the state of that job
Future -  has a get() method

Interfaces - are like defining a contract

Pattern Matching for instanceOf - Java16 onwards - not fully understood
Patttern Matching for Switch case - Java21 onwards

Foreign functions - replacement for native - 
java.lang.foreign

Vector API - Java's attempt at data science - calling a C function for the sake of performance

Improved Null Processing - Optional<T> - Java 8 onwards
Optional is a class.  Optional.orElse() is a method to avoid getting a null result. In case, if it is empty, what should I put ?

Checked and UnChecked Exceptions
Throws is compulsory for Checked Exception
During compilation, compiler will check if you have used the word "throws" for all applicable checked exceptions.  It doesnot check use of throws for unchecked exceptions.

throws E1 - means -I have used statements where E1 can occur, but I am not handling E1. throws means I am not handling the exception.

String
String Buffer - mutable avatar - not to be used now
String Builder - mutable avatar - can be used
If immutable, every time we make a change, a new object is created,so new memory and more task for the GC
If mutable class is used, then new objects are not created. The same object is getting modified








<focus only on Java>





ACDEFGHIJKLMOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz

Pedig
1. EPU format-Google, Amazo Google

